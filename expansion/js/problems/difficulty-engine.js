// Adaptive Difficulty Engine
// Adjusts problem difficulty based on user performance

export function adjustDifficulty(recentResults, currentDifficulty = 'medium') {
  if (recentResults.length < 5) return currentDifficulty;

  const recent5 = recentResults.slice(-5);
  const correctCount = recent5.filter(r => r.correct).length;
  const avgTime = recent5.reduce((sum, r) => sum + (r.timeSeconds || 0), 0) / recent5.length;
  const fastThreshold = 15; // seconds

  // All correct and fast → increase difficulty
  if (correctCount === 5 && avgTime < fastThreshold) {
    return increaseDifficulty(currentDifficulty);
  }

  // 2+ errors → decrease difficulty
  if (correctCount <= 3) {
    return decreaseDifficulty(currentDifficulty);
  }

  // Otherwise, maintain current difficulty
  return currentDifficulty;
}

export function selectNextProblem(level, operation, userHistory, activeMisunderstandings = []) {
  // 1. Priority: Remediation for active misunderstandings
  if (activeMisunderstandings.length > 0) {
    return {
      type: 'remediation',
      misunderstanding: activeMisunderstandings[0],
      // Would integrate with remediation engine
      problem: null // Placeholder - would call remediation system
    };
  }

  // 2. Spaced repetition: bring back previously struggled problems
  const dueForReview = getSpacedRepetitionDue(userHistory);
  if (dueForReview.length > 0 && Math.random() < 0.3) {
    return {
      type: 'review',
      problem: dueForReview[0]
    };
  }

  // 3. New material at edge of ability
  const recentPerformance = userHistory.slice(-5);
  const currentDifficulty = getCurrentDifficulty(userHistory);
  const adjustedDifficulty = adjustDifficulty(recentPerformance, currentDifficulty);

  return {
    type: 'new',
    difficulty: adjustedDifficulty,
    problem: null // Will be generated by problem-generator
  };
}

export function getCurrentDifficulty(userHistory) {
  if (userHistory.length === 0) return 'easy';

  // Find most recent difficulty setting
  for (let i = userHistory.length - 1; i >= 0; i--) {
    if (userHistory[i].difficulty) {
      return userHistory[i].difficulty;
    }
  }

  return 'medium';
}

export function shouldUnlockNextLevel(levelHistory, currentLevel) {
  // Unlock criteria: 70%+ accuracy over last 20 problems OR 80%+ over last 10
  if (levelHistory.length < 10) return false;

  const last10 = levelHistory.slice(-10);
  const correct10 = last10.filter(r => r.correct).length;
  const accuracy10 = correct10 / 10;

  if (accuracy10 >= 0.8) return true;

  if (levelHistory.length >= 20) {
    const last20 = levelHistory.slice(-20);
    const correct20 = last20.filter(r => r.correct).length;
    const accuracy20 = correct20 / 20;

    if (accuracy20 >= 0.7) return true;
  }

  return false;
}

export function recommendMethod(problem, userMethodMastery = {}) {
  // Basic recommendation based on problem characteristics
  // This would integrate with method-selector.js in real implementation

  const { a, operation, b, metadata } = problem;

  if (operation === '-' && metadata.smallDifference) {
    return 'counting_on';
  }

  if (metadata.nearRound) {
    return 'compensation';
  }

  if (metadata.borrows === 0 && metadata.carries === 0) {
    return 'partitioning';
  }

  if (metadata.chainBorrow) {
    return 'column';
  }

  return 'sequencing';
}

function increaseDifficulty(current) {
  const order = ['easy', 'medium', 'hard'];
  const idx = order.indexOf(current);
  return idx < order.length - 1 ? order[idx + 1] : current;
}

function decreaseDifficulty(current) {
  const order = ['easy', 'medium', 'hard'];
  const idx = order.indexOf(current);
  return idx > 0 ? order[idx - 1] : current;
}

function getSpacedRepetitionDue(userHistory) {
  const now = Date.now();
  const dueProblems = [];

  // Look for problems that were attempted, got wrong, and are due for review
  const struggled = userHistory.filter(r => !r.correct && r.attempts >= 2);

  for (const result of struggled) {
    const timeSince = now - (result.timestamp || 0);
    const daysSince = timeSince / (1000 * 60 * 60 * 24);

    // Spaced repetition intervals: review after 1 day, 3 days, 7 days
    if (result.reviewCount === 0 && daysSince >= 1) {
      dueProblems.push({ ...result.problem, reviewCount: 1 });
    } else if (result.reviewCount === 1 && daysSince >= 3) {
      dueProblems.push({ ...result.problem, reviewCount: 2 });
    } else if (result.reviewCount === 2 && daysSince >= 7) {
      dueProblems.push({ ...result.problem, reviewCount: 3 });
    }
  }

  return dueProblems;
}

export function calculatePracticeSessionStats(results) {
  const total = results.length;
  const correct = results.filter(r => r.correct).length;
  const accuracy = total > 0 ? correct / total : 0;
  const avgTime = results.reduce((sum, r) => sum + (r.timeSeconds || 0), 0) / (total || 1);

  const methodsUsed = {};
  results.forEach(r => {
    if (r.methodUsed) {
      methodsUsed[r.methodUsed] = (methodsUsed[r.methodUsed] || 0) + 1;
    }
  });

  const struggledProblems = results.filter(r => !r.correct || r.timeSeconds > 30);

  return {
    total,
    correct,
    incorrect: total - correct,
    accuracy,
    avgTime,
    methodsUsed,
    struggledProblems,
    timestamp: Date.now()
  };
}
